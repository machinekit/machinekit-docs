= Writing HAL Components for Machinekit

Recommended pre-reading from the legacy docs.

link:../../src/hal/intro.asciidoc[Introduction to HAL]

link:../../src/hal/tutorial.asciidoc[Basic HAL tutorial]

Quite often there are existing components that can achieve your ends, without the need to write 
one yourself.

Certainly, maths and logic components are very well catered for.

link:../../src/hal/components.asciidoc[This] is a brief resume of the existing 'stock' components

link:../index-instantiated-components.asciidoc[This] is an index of Instantiated Component man pages

==  C files

The most powerful and flexible method of writing components, is to write them in C.

If you are conversant with C, you can study other components to see the layout and function calls required and use
one of them as a template to base your component upon.

The components written directly in C are to be found mainly in

[blue]#src/hal/components#

There are device drivers in 

[blue]#src/hal/drivers#

==  Generated files

A much simpler method is to use the preprocessor / compiler tools provided with Machinekit.


With the minimum of knowledge of hal and rtapi internals, the user can create a working component.

The user does have to know how to write the main function code in C however, there are only a certain number of
shortcuts to enlightenment.

=== comp

link:../../src/hal/comp.asciidoc[comp] is the legacy (linuxcnc) component generator.

comp will generate and compile components for rt or userspace.

It takes shorthand and macro options, plus the code to be used in the function proper of the component,
and generates a C file from templates to contain the function code.

It also builds a full component.

=== instcomp

link:../../src/hal/instcomp.asciidoc[instcomp] is the new Machinekit instantiated component generator, developed and extended from comp.

The essential difference between normal realtime components and instantiable components,
is that 'normal components' are loaded once only and have to create as many copies of the
component as they need, all at once, there and then.

Instantiable components load the 'base component' and from that can create instances 
of the component whenever they are required.
So instances can be created in separate hal files, on-the-fly or whatever.

Further info link:../../src/hal/new-instantiated-components.asciidoc[here]

Amoungst many advantages, it opens up huge flexibility in configuration.

The options for *instcomp* differ from *comp* but are overall similar.
The code generated differs hugely from that generated by comp.

There are over 80 components converted to *instcomp* from the legacy components, so there is
a wealth of examples to follow and adapt

They can be found at [blue]#src/hal/i_components#

== Python components

It is possible to write userspace components in python, using the python bindings for the C libraries.

It cannot be used for time sensitive or realtime components, because python is a scripted, interpreted 
language, but a lot of components have no need of milli-second poll timing and can quite happily be
written as userspace using python

This link:../../src/hal/halmodule.asciidoc[link] gives some basic information.

There are not that many examples,  some in [blue]#src/hal/user_comps#

but the best well known one, is part of every basic machine config

[blue]#src/emc/usr_intf/axis/scripts/hal_manualtoolchange.py#


